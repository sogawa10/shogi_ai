千日手・持将棋・最大手数
はまだ

了解した．方針はとても良いと思う．
既存の main や入出力ロジックはいったん全て忘れて，盤面クラスと駒クラスだけを「エンジン」として使い，pvp 用の最小構成から一緒に組み直そう．

以下では，

・何を「触らない核」にするか
・pvp 用に必要な最小要素
・最初に書くべき main の骨格

を整理したうえで，今すぐ動かせる最小コード を提示する．
以降はこのコードを少しずつ拡張していく前提で進めよう．

1．触らない「核」

既に作っている以下は エンジン層 として固定するのがよい．

・盤面 クラス
・駒 クラス（歩，香，桂，…）
・手 クラス
・generate_board_moves
・generate_uchite
・filter_shogi_rules
・apply_move

pvp 側では，

・合法手生成
・盤面更新

を 呼び出すだけ にする．
ここを直接いじらないことが，バグを抑える最大のポイントだ．

2．pvp 用に必要な最小要素

人間対人間（pvp）に必要なのは以下だけである．

・盤面を表示する
・入力を受け取る
・入力を「手」に変換する
・合法手か確認する
・盤面を更新する
・手番を進める

AI 要素は一切不要だ．

3．最小構成の設計
レイヤ分離
pvp_main.py
 ├─ 表示（print_board）
 ├─ 入力（input_move）
 └─ ループ（while）


盤面ロジックは一切書かない．

4．まずはこれだけ書こう（最小 pvp）
pvp_main.py
from src.盤面 import 盤面
from src.手 import 手
from src.駒 import *

def print_board(board):
    print("  8 7 6 5 4 3 2 1 0")
    for y in range(9):
        row = []
        for x in range(9):
            koma = board.board[x][y]
            row.append(koma.symbol() if koma else "・")
        print(f"{y} " + " ".join(row))
    print()

def print_motigoma(board):
    print("先手 持駒:", " ".join(k.symbol() for k in board.motigoma["先手"]))
    print("後手 持駒:", " ".join(k.symbol() for k in board.motigoma["後手"]))
    print()

def input_move():
    print("入力例")
    print("移動: fx fy tx ty [n]")
    print("打ち: P tx ty")
    return input("> ").strip().split()

def parse_move(board, tokens):
    # 打ち
    if len(tokens) == 3 and tokens[0] in {"P","L","N","S","G","B","R"}:
        tx, ty = map(int, tokens[1:])
        cls = {"P":歩,"L":香,"N":桂,"S":銀,"G":金,"B":角,"R":飛}[tokens[0]]
        for k in board.motigoma[board.turn]:
            if type(k) is cls:
                return 手(k, None, (tx, ty), uchite=True)
        return None

    # 移動
    if len(tokens) in (4, 5):
        fx, fy, tx, ty = map(int, tokens[:4])
        nari = len(tokens) == 5 and tokens[4] == "n"
        koma = board.board[fx][fy]
        if koma is None:
            return None
        return 手(koma, (fx, fy), (tx, ty), nari=nari)

    return None

def main():
    board = 盤面()

    while True:
        print_board(board)
        print_motigoma(board)
        print(f"{board.turn} の手番")

        board_moves = board.generate_board_moves(board.turn)
        uchite_moves = board.generate_uchite(board.turn)
        legal_moves = board.filter_shogi_rules(board_moves, uchite_moves)

        tokens = input_move()
        move = parse_move(board, tokens)
        if move is None:
            print("入力エラー\n")
            continue

        # 合法手チェック（構造一致）
        for lm in legal_moves:
            if (
                lm.from_pos == move.from_pos
                and lm.to_pos == move.to_pos
                and lm.uchite == move.uchite
                and type(lm.koma) is type(move.koma)
                and lm.nari == move.nari
            ):
                board = board.apply_move(lm)
                break
        else:
            print("非合法手\n")

if __name__ == "__main__":
    main()

5．この段階での重要ポイント

・move.koma は 必ず盤面 or 持ち駒に存在する実体
・合法手判定は「値」ではなく「構造一致」
・pvp 側では駒を新規生成しない

これが守れていれば，
打ち・移動・成り・持ち駒 すべて安定する．

次にやると良いこと

次のステップ候補を挙げる．どれから行くか選んでほしい．

1．x 座標を将棋表記（９〜１）に変換
2．「同　歩」「▲７六歩」風の棋譜表示
3．詰み・千日手判定
4．入力を自然言語寄りにする
5．GUI（pygame / tkinter）

どれを先にやるか決めよう．